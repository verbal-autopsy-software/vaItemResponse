#' Translate ODK relevant field
#'
#' \code{translate} converts conditions in ODK to R.
#'
#' @param relevant A string from ODK$relevant that needs to be translated.
#'
#' @details
#' This is a worker function.
#' 
#' @examples
#' \dontrun{
#' ## Example with 2016 WHO VA instrument version 1.5.1
#' library(vaItemResponse)
#' data(who2016_151_instrument)
#' relevant <- who2016_151_instrument$relevant[15]
#' translate(relevant)
#' }
#'
#' @importFrom stringi stri_replace_all_regex stri_count_words
#' @export
#'
translate <- function (relevant) {

    # remove \n
    pattern_selected <- "\n"
    new_relevant <- stri_replace_all_regex(relevant, pattern_selected, " ")

    # replace = with == (but not for >= or <= or !=)
    pattern_selected <- "(?<![>|<|!])="
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_selected, "==")

    # translate selected() -- maybe have separate functions for these
    pattern_selected <- "(?<!not\\()selected\\(\\$\\{([^\\}]+)\\}[^']+('[^']+')\\)"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_selected, "death\\$$1 == $2")

    # translate not(selected())
    pattern_not_selected <- "not\\(selected\\(\\$\\{([^\\}]+)\\}[^']+('[^']+')\\)\\)"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_not_selected, "death\\$$1 != $2")

    # translate ${field_name} (separately for !=, =, >, and <)
    # \\1 = field name, \\2 = }, \\3 = relational operator/comparators
    pattern_field_eq <- "(?<!selected\\()\\$\\{([^\\}]+)(\\})[:space:]*([=|!|>|<]=*)[:space:]*"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field_eq, "death\\$$1 $3 ")
 
    # translate or replace " or " with " | "
    new_relevant <- stri_replace_all_regex(new_relevant, " or ", " | ")
    new_relevant <- stri_replace_all_regex(new_relevant, "\\)or", ") | (")
    new_relevant <- stri_replace_all_regex(new_relevant, "or\\(", ") | (")
    
    # translate and odkForm$relevant[437]
    new_relevant <- stri_replace_all_regex(new_relevant, "[:space:]+and[:space:]+", " & ")
    ## new_relevant <- stri_replace_all_regex(new_relevant, "\\)and", " & ")
    ## new_relevant <- stri_replace_all_regex(new_relevant, "and\\(", " & ")
    new_relevant <- stri_replace_all_regex(new_relevant, "([:punct:])and", "$1 &")
    new_relevant <- stri_replace_all_regex(new_relevant, "and([:punct:])", "& $1")

    # translate 'NaN' (note previous conversions with = and with field name)
    ## is.na() == TRUE
    pattern_field_eq <- "death\\$([^[:space:][:punct:]]+)[:space:]*==[:space:]*'NaN'"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field_eq, "is.na(death\\$$1)")
    ## is.na() == FALSE
    pattern_field_neq <- "death\\$([^[:space:][:punct:]]+)[:space:]*!=[:space:]*'NaN'"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field_neq, "!is.na(death\\$$1)")

    # translate string-length(${ageInMonthsByYear}) = 0)) with nchar
    pattern_field <- "string-length\\(\\$\\{([^\\}]+)\\}\\)"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field, "nchar(death\\$$1)")

    # translate count-selected 
    pattern_field <- "count-selected\\(\\$\\{([^\\}]+)\\}\\)"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field, "stri_count_words(death\\$$1)")

    ## devtools::test_file('../tests/testthat/test-item-response.R')
    return(new_relevant)
}


#' Construct item names that capture the hierarchical of an ODK questionnare.
#'
#' \code{itemHierarchy} map the ODK questionnaire hierarchy (i.e. a replication
#' of the field names generated by ODK Aggregate and used in the CSV export).
#'
#' @param odk_form A data frame containing an ODK form.
#'
#' @details
#' Returns the the same data frame, but with an additional column
#' consisting of the group names each item belongs to.  The group names
#' are separated by ".".
#' 
#' @examples
#' \dontrun{
#' ## Example with 2016 WHO VA instrument version 1.5.1
#' 
#' ## Example with 2016 WHO VA instrument version 1.5.1
#' library(vaItemResponse)
#' data(who2016_151_instrument)
#' item_groups <- itemHierarchy(who2016_151_instrument)$item_groups
#' }
#'
#' @importFrom stringi stri_replace_all_regex stri_count_words
#' @export
#'
itemHierarchy <- function (odk_form) {

    skip_row <- odk_form$type == ""
    new_form <- odk_form
    new_form$item_groups <- ""
    current_name <- ""
    n_groups <- 0

    nNames <- function (item_names) {
        # return the number of groups in groupNames
        split_names <- strsplit(item_names, "\\.")
        all_names <- unlist(split_names)
        return (length(all_names))
    }

    removeLastName <- function (item_names) {
        # remove last group name; groups separated by a period
        split_names <- strsplit(item_names, "\\.")
        all_names <- unlist(split_names)
        n <- length(all_names)
        names_to_keep <- unlist(split_names)[-n]
        return (paste0(names_to_keep, collapse = "."))
    }
    
    for (i in 1:length(skip_row)) {

        if (skip_row[i]) next

        if (new_form$type[i] == "begin group" & nNames(current_name) == 0) {
            current_name <- new_form$name[i]
            n_groups <- n_groups + 1
            new_form$item_groups[i] <- current_name
        } else if (new_form$type[i] == "begin group" & nNames(current_name) > 0) {
            current_name <- paste0(c(current_name, new_form$name[i]), collapse = ".")
            n_groups <- n_groups + 1
            new_form$item_groups[i] <- current_name
        } else if (new_form$type[i] == "end group") {
            current_name <- removeLastName(current_name)
            n_groups <- n_groups - 1
            next
        } else {
            current_name <- paste0(c(current_name, new_form$name[i]),
                                   collapse = ".")
            new_form$item_groups[i] <- current_name
            current_name <- removeLastName(current_name)
        }
    }

    ## devtools::test_file('../tests/testthat/test-item-response.R')
    return (new_form)
}


##' Attempt to find root questions in the ODK Instrument.
##'
##' Makes several assumptions, probably makes a few mistakes.
##' 
##' @param odk_form A data frame with the ODK instrument
##' @param ignoreAge A logical to indicate if age-related items should be ignored
##' (as parents) as determined by the relevant field.
##' @param ignoreSex A logical to indicate if sex should be ignored
##' (as parents) as determined by the relevant field.
##' @param ignoreStillBirth A logical to indicate if the still birth item should
##' be ignored (as parents) as determined by the relevant field.
##' @param ignorePregnant A logical to indicate if the pregnancy item should
##' be ignored (as parents) as determined by the relevant field.
##' @return A list of item names and labels (both strings) of the root questions.
##'
##' @export
##'
findRoot <- function(odk_form, ignoreAge=TRUE, ignoreSex=TRUE, ignoreStillBirth=TRUE, ignorePregnant=TRUE) {
  
  roots_name <- NULL
  roots_label <- NULL
  new_odk_form <- itemHierarchy(odk_form)
  clean_form <- new_odk_form[new_odk_form$name != "",]
  clean_form$label <- clean_form$"label..English"
  clean_form <- clean_form[, !(names(new_odk_form) %in% "label..English")]
  
  for (i in 1:nrow(clean_form)) {
    
    skip_types <- c("begin group", "end group", "calculate", "note")
    if (clean_form$type[i] %in% skip_types) next

    depends <- strsplit(clean_form$item_group[i], "\\.")
    depends <- unlist(depends)
    index_depends <- which(clean_form$name %in% depends)
    depends_relevant <- clean_form$relevant[index_depends]
    if (all(depends_relevant == "")) {
      # then I think clean_form$name[i] is a root item
      names_relevant <- NULL
    } else {
      translated_relevant <- vapply(depends_relevant,
                                    translate,
                                    FUN.VALUE = character(1),
                                    USE.NAMES = FALSE)
      translated_relevant <- translated_relevant[!(translated_relevant == "")]
      list_names_relevant <- lapply(clean_form$name, function (x) grepl(x, translated_relevant, fixed = TRUE))
      index_names_relevant <- lapply(list_names_relevant, function (x) any(x))
      names_relevant <- clean_form$name[unlist(index_names_relevant)]
    }
    # remove consent Id10013 and ignores; if length > 0, then not a root
    final_names_relevant <- names_relevant[names_relevant != "Id10013"]
    if (ignoreAge) {
      final_names_relevant <- final_names_relevant[!grepl("age", tolower(final_names_relevant), fixed = TRUE)]
      final_names_relevant <- final_names_relevant[!grepl("isneo", tolower(final_names_relevant), fixed = TRUE)]
      final_names_relevant <- final_names_relevant[!grepl("isadult", tolower(final_names_relevant), fixed = TRUE)]
      final_names_relevant <- final_names_relevant[!grepl("ischild", tolower(final_names_relevant), fixed = TRUE)]
    }
    if (ignoreSex) final_names_relevant <- final_names_relevant[final_names_relevant != "Id10019"]
    if (ignoreStillBirth) final_names_relevant <- final_names_relevant[final_names_relevant != "Id10114"]
    if (ignorePregnant) final_names_relevant <- final_names_relevant[final_names_relevant != "Id10310"]
    
    if (length(final_names_relevant) == 0) {
      roots_name <- c(roots_name, clean_form$name[i])
      roots_label <- c(roots_label, clean_form$label[i])
    }
  }
  roots <- list(name = roots_name, label = roots_label)

  return (roots)
}


##' Identify which demographic groups are eligible for each item.
##'
##' It may be of interest to stratify item response results by
##' demographic groups.  This function, used by \code{itemMissing},
##' makes this task easier.  The demographic groups include
##' adults, children, neonates, and mothers.
##'
##' @param odk_form A data frame with the ODK instrument
##' 
##' @return A list of vectors with ODK items as rows and columns that
##' indicate if the item can appear in the interview for the
##' corresponding demographic group.
##' 
##' @importFrom stringi stri_match_all_regex
##' @export
##' 
demGroups <- function (odk_form) {
    
    form <- itemHierarchy(odk_form)
    q_adult <- NULL
    q_child <- NULL
    q_neonatal <- NULL
    q_problem <- NULL
    row_skip <- c("begin group", "end group", "note", "start", "end", "comment")

    for (i in 1:nrow(form)) { # i = 328

        if (form$type[i] %in% row_skip) next
        depends <- strsplit(form$item_group[i], "\\.")
        depends <- unlist(depends)
        index_depends <- which(form$name %in% depends)
        depends_relevant <- form$relevant[index_depends]

        ## Adults
        is_adult1 <- "(?<!not\\()selected\\(\\$\\{isAdult\\},[:blank:]*'1'"
        is_adult2 <- "\\$\\{isAdult\\}[:blank:]*=[:blank:]*'1'"
        check_match1 <- unlist(stri_match_all_regex(depends_relevant, is_adult1, omit_no_match = TRUE))
        check_match2 <- unlist(stri_match_all_regex(depends_relevant, is_adult2, omit_no_match = TRUE))
        found_match <- length(check_match1) > 0 | length(check_match2)

        not_is_adult1 <- "not\\(selected\\(\\$\\{(isAdult]+)\\},+('[^']+')\\)\\)"
        not_is_adult2 <- "\\$\\{isAdult\\}[:blank:]*\\!=[:blank:]*'1'"
        check_no_match1 <- unlist(stri_match_all_regex(depends_relevant, not_is_adult1, omit_no_match = TRUE))
        check_no_match2 <- unlist(stri_match_all_regex(depends_relevant, not_is_adult2, omit_no_match = TRUE))
        found_no_match <- length(check_no_match1) > 0 | length(check_no_match2)
        if (found_match & found_no_match) {
            q_problem <- c(q_problem, form$name[i])
        }
        if (found_match & ! found_no_match) {
            q_adult <- c(q_adult, form$name[i])
        }
        
        ## Children
        is_child1 <- "(?<!not\\()selected\\(\\$\\{isChild\\},[:blank:]*'1'"
        is_child2 <- "\\$\\{isChild\\}[:blank:]*=[:blank:]*'1'"
        check_match1 <- unlist(stri_match_all_regex(depends_relevant, is_child1, omit_no_match = TRUE))
        check_match2 <- unlist(stri_match_all_regex(depends_relevant, is_child2, omit_no_match = TRUE))
        found_match <- length(check_match1) > 0 | length(check_match2)

        not_is_child1 <- "not\\(selected\\(\\$\\{(isChild]+)\\},+('[^']+')\\)\\)"
        not_is_child2 <- "\\$\\{isChild\\}[:blank:]*\\!=[:blank:]*'1'"
        check_no_match1 <- unlist(stri_match_all_regex(depends_relevant, not_is_child1, omit_no_match = TRUE))
        check_no_match2 <- unlist(stri_match_all_regex(depends_relevant, not_is_child2, omit_no_match = TRUE))
        found_no_match <- length(check_no_match1) > 0 | length(check_no_match2)
        if (found_match & found_no_match) {
            q_problem <- c(q_problem, form$name[i])
        }
        if (found_match & ! found_no_match) {
            q_child <- c(q_child, form$name[i])
        }
        
        ## Neonates
        is_neonatal1 <- "(?<!not\\()selected\\(\\$\\{isNeonatal\\},[:blank:]*'1'"
        is_neonatal2 <- "\\$\\{isNeonatal\\}[:blank:]*=[:blank:]*'1'"
        check_match1 <- unlist(stri_match_all_regex(depends_relevant, is_neonatal1, omit_no_match = TRUE))
        check_match2 <- unlist(stri_match_all_regex(depends_relevant, is_neonatal2, omit_no_match = TRUE))
        found_match <- length(check_match1) > 0 | length(check_match2)

        not_is_neonatal1 <- "not\\(selected\\(\\$\\{(isNeonatal]+)\\},+('[^']+')\\)\\)"
        not_is_neonatal2 <- "\\$\\{isNeonatal\\}[:blank:]*\\!=[:blank:]*'1'"
        check_no_match1 <- unlist(stri_match_all_regex(depends_relevant, not_is_neonatal1, omit_no_match = TRUE))
        check_no_match2 <- unlist(stri_match_all_regex(depends_relevant, not_is_neonatal2, omit_no_match = TRUE))
        found_no_match <- length(check_no_match1) > 0 | length(check_no_match2)
        if (found_match & found_no_match) {
            q_problem <- c(q_problem, form$name[i])
        }
        if (found_match & ! found_no_match) {
            q_neonatal <- c(q_neonatal, form$name[i])
        }
    }
    items_maternal <- form[grep("pregnancy", form$item_groups),]
    q_maternal <- items_maternal$name[items_maternal$type != "begin group"]

    index_all <- !(form$name %in% q_adult) &
        !(form$name %in% q_child) &
        !(form$name %in% q_neonatal) &
        !(form$type %in% row_skip)

    q_all <- form$name[index_all]

    q_adult <- c(q_adult, q_all)
    q_child <- c(q_child, q_all)
    q_neonatal <- c(q_neonatal, q_all)

    # re-order to match odk form
    q_adult <- q_adult[order(match(q_adult, form$name))]
    q_child <- q_child[order(match(q_child, form$name))]
    q_neonatal <- q_neonatal[order(match(q_neonatal, form$name))]

    q_list <-list(adults = q_adult,
                  children = q_child,
                  neonates = q_neonatal,
                  maternal = q_maternal)

    return (q_list)
}


#' Calculate item missingness.
#'
#' \code{itemMissing} 
#'
#' @param odk_data A data frame with ODK data
#' @param odk_form A data frame containing an ODK form.
#' @param id_col A string with column name in odk_data with ID (default is "meta.instanceID")
#' @param check_parents A logical (default is TRUE) to implement a more
#' aggressive check of skip patterns (i.e., include parent's dependents).
#' 
#' @details
#' List with two data frames Deaths and Items.
#' 
#' @examples
#' \dontrun{
#' ## Example with 2016 WHO VA instrument version 1.5.1
#' 
#' ## Example with 2016 WHO VA instrument version 1.5.1
#' library(vaItemResponse)
#' data(who2016_151_data)
#' data(who2016_151_instrument)
#' results <- itemMissing(who2016_151_data, who2016_151_instrument)
#' }
#'
#' @importFrom stringi stri_endswith_fixed
#' @export
#'
itemMissing <- function(odk_data, odk_form, id_col = "meta.instanceID", check_parents = TRUE) {

    ## set up input data
    split_names <- strsplit(names(odk_data), "\\.")
    death_fnames <- unlist(lapply(split_names, function (x) x[length(x)]))
    death_fnames <- tolower(death_fnames)
    ## names(odk_data) <- death_fnames
    new_odk_form <- itemHierarchy(odk_form)
    clean_form <- new_odk_form[new_odk_form$name != "",]
    clean_form$label <- clean_form$"label..English"
    clean_form <- clean_form[, !(names(new_odk_form) %in% "label..English")]

    ## set up output data
    n_deaths <- nrow(odk_data)
    index_ID <- which(stri_endswith_fixed(names(odk_data), id_col))
    if (length(index_ID)) {
        DEATHS <- data.frame(ID = odk_data[, index_ID],
                             n_items = rep(0, n_deaths),
                             n_ref = rep(0, n_deaths),
                             n_dk = rep(0, n_deaths),
                             n_miss = rep(0, n_deaths),
                             n_yes = rep(0, n_deaths),
                             n_no = rep(0, n_deaths),
                             stringsAsFactors = FALSE)
    } else {
        ## message("Did not find id_col, so assigning row numbers for IDs.",
        ##         call. = FALSE)
        DEATHS <- data.frame(ID = 1:n_deaths,
                             n_items = rep(0, n_deaths),
                             n_ref = rep(0, n_deaths),
                             n_dk = rep(0, n_deaths),
                             n_miss = rep(0, n_deaths),
                             n_yes = rep(0, n_deaths),
                             n_no = rep(0, n_deaths)
                             )
    }

    ITEMS <- clean_form[, c('type', 'name', 'label', 'relevant', 'required')]
    ITEMS$n_asked <- rep(0, nrow(clean_form))
    ITEMS$n_ref <- rep(0, nrow(clean_form))
    ITEMS$n_dk <- rep(0, nrow(clean_form))
    ITEMS$n_miss <- rep(0, nrow(clean_form))
    ITEMS$n_yes <- rep(0, nrow(clean_form))
    ITEMS$n_no <- rep(0, nrow(clean_form))
    ITEMS$var <- rep(0, nrow(clean_form))
    ITEMS$entropy <- rep(0, nrow(clean_form))

    ## include warning message about which fields are in data, but not in form
    ## and vice versa.

    names(odk_data) <- tolower(death_fnames)
    odk_data$item_response_ID <- DEATHS$ID
    ITEM_DEATH_DUMMY <- odk_data
    ITEM_DEATH_DUMMY <- lapply(odk_data, function (x) as.character(x))
    ITEM_DEATH_DUMMY <- as.data.frame(ITEM_DEATH_DUMMY)
    ITEM_DEATH_DUMMY[1:nrow(odk_data), 1:ncol(odk_data)] <- FALSE
    ITEM_DEATH_DUMMY$item_response_ID <- odk_data$item_response_ID
    for (i in 1:ncol(odk_data)) {

        index_form <- which(tolower(clean_form$name) == tolower(death_fnames[i]))

        if (length(index_form) == 0) next
        #if (clean_form$type[index_form] == "calculate") next
        
        depends <- strsplit(clean_form$item_group[index_form], "\\.")
        depends <- unlist(depends)
        index_depends <- which(clean_form$name %in% depends)
        depends_relevant <- clean_form$relevant[index_depends]
        if (check_parents) {
            last_relevant <- tail(depends_relevant, n = 1)
            clean_last_relevant <- gsub("\\$\\{[^\\}]*\\}[ ]*!", "", last_relevant)
            clean_last_relevant <- gsub("not\\(selected\\(\\$\\{[^\\}]*\\}", "", clean_last_relevant)
            clean_last_relevant <- gsub("Id10114", "", clean_last_relevant)
            parent_depends <- stri_match_all_regex(clean_last_relevant,
                                                   pattern = "\\$\\{[^\\}]*\\}",
                                                   omit_no_match=TRUE)
            parent_depends <- unlist(parent_depends)
            parent_depends <- gsub("\\$\\{|\\}", "", parent_depends)
            if (length(parent_depends) > 0) {
                index_depends <- c(index_depends,
                                   which(clean_form$name %in% parent_depends))
                depends_relevant <- clean_form$relevant[index_depends]
            }
        }
        if (all(depends_relevant == "")) {
            responses <- odk_data
        } else {
            translated_relevant <- vapply(depends_relevant,
                                          translate,
                                          FUN.VALUE = character(1),
                                          USE.NAMES = FALSE)
            translated_relevant <- translated_relevant[!(translated_relevant == "")]
            combined_relevant <- paste0("(", translated_relevant, ")", collapse = " & ")
            combined_relevant <- gsub("death\\$", "odk_data\\$", combined_relevant)
            responses <- eval(parse(text = paste0("subset(odk_data,", tolower(combined_relevant), ")")))
        }

        # fill in DEATHS
        ## what if type == integer is in relevant?  Only found: id10309 (has string-length)
        value_ref <- "ref"
        value_dk <- "dk"
        if (clean_form$type[index_form] == "integer") {
            value_ref <- 88
            value_dk <- 99
        }
        if (tolower(clean_form$name[index_form]) == "id10366") {
            ## special case: weight in grammes of the deceased at birth
            value_ref <- 8888
            value_dk <- 9999
        }

        DEATHS_index <- match(responses$item_response_ID, DEATHS$ID)
#        if (is.character(responses[, death_fnames[i]])) {
            DEATHS[DEATHS_index, "n_items"] <- DEATHS[DEATHS_index, "n_items"] + 1
            DEATHS[DEATHS_index, "n_ref"] <- DEATHS[DEATHS_index, "n_ref"] +
                as.numeric(tolower(responses[, death_fnames[i]]) == value_ref)
            DEATHS[DEATHS_index, "n_dk"] <- DEATHS[DEATHS_index, "n_dk"] +
                as.numeric(tolower(responses[, death_fnames[i]]) == value_dk)
            DEATHS[DEATHS_index, "n_miss"] <- DEATHS[DEATHS_index, "n_miss"] +
                as.numeric(
                    tolower(responses[, death_fnames[i]]) == "" |
                    is.na(responses[, death_fnames[i]])
                )
            DEATHS[DEATHS_index, "n_yes"] <- DEATHS[DEATHS_index, "n_yes"] +
                as.numeric(tolower(responses[, death_fnames[i]]) == "yes")
            DEATHS[DEATHS_index, "n_no"] <- DEATHS[DEATHS_index, "n_no"] +
                as.numeric(tolower(responses[, death_fnames[i]]) == "no")
 #       }
        ## for numeric (skip calculate?); for integer, looks like they are almost all 99 for don't know
        ## and 88 for refused.  Birth weight uses 9999 and 8888.
        # fill in ITEMS
#        if (is.character(responses[, death_fnames[i]]) ) {
            ITEMS[index_form, "n_asked"] <- ITEMS[index_form, "n_asked"] +
                nrow(responses)
            ITEMS[index_form, "n_ref"] <- ITEMS[index_form, "n_ref"] +
                sum(tolower(responses[, death_fnames[i]]) == value_ref, na.rm = TRUE)
            ITEMS[index_form, "n_dk"] <- ITEMS[index_form, "n_dk"] +
                sum(tolower(responses[, death_fnames[i]]) == value_dk, na.rm = TRUE)
            ITEMS[index_form, "n_miss"] <- ITEMS[index_form, "n_miss"] +
                sum(tolower(responses[, death_fnames[i]]) == "" |
                    is.na(responses[, death_fnames[i]]))
            ITEMS[index_form, "n_yes"] <- ITEMS[index_form, "n_yes"] +
                sum(tolower(responses[, death_fnames[i]]) == "yes", na.rm = TRUE)
            ITEMS[index_form, "n_no"] <- ITEMS[index_form, "n_no"] +
                sum(tolower(responses[, death_fnames[i]]) == "no", na.rm = TRUE)

            missing <- responses[, death_fnames[i]] == "" | is.na(responses[, death_fnames[i]])
            tab <- table(responses[!missing, death_fnames[i]])
            ptab <- tab/sum(tab)
            ITEMS[index_form, "var"] <- stats::var(ptab, na.rm = TRUE)
            ITEMS[index_form, "entropy"] <- -1*sum(ptab*log(ptab))

            ITEM_DEATH_DUMMY[ITEM_DEATH_DUMMY$item_response_ID %in% responses$item_response_ID,
                             i] <- TRUE
#        }
    }
    ITEMS$"label" <- iconv(ITEMS$"label", "UTF-8", "ASCII", sub=" ")
    ITEMS$"label" <- stri_replace_all_regex(ITEMS$"label", "\n", "")
    ITEMS$"label" <- stri_replace_all_regex(ITEMS$"label", "\"", "'")

#        DEATHS$pct_total <- DEATHS$n_items/max(DEATHS$n_total, na.rm = TRUE)
    DEATHS$pct_ref <- 100*DEATHS$n_ref/DEATHS$n_items
    DEATHS$pct_dk <- 100*DEATHS$n_dk/DEATHS$n_items
    DEATHS$pct_mis <- 100*DEATHS$n_mis/DEATHS$n_items
    DEATHS$pct_yes <- 100*DEATHS$n_yes/DEATHS$n_items
    DEATHS$pct_no <- 100*DEATHS$n_no/DEATHS$n_items

    ITEMS$pct_total <- 100*ITEMS$n_asked/max(ITEMS$n_asked, na.rm = TRUE)
    ITEMS$pct_ref <- 100*ITEMS$n_ref/ITEMS$n_asked
    ITEMS$pct_dk <- 100*ITEMS$n_dk/ITEMS$n_asked
    ITEMS$pct_miss <- 100*ITEMS$n_miss/ITEMS$n_asked
    ITEMS$pct_yes <- 100*ITEMS$n_yes/ITEMS$n_asked
    ITEMS$pct_no <- 100*ITEMS$n_no/ITEMS$n_asked

    q_root <- findRoot(odk_form)$name
    q_dem_groups <- demGroups(odk_form)
    ITEMS$root_item <- ITEMS$name %in% q_root
    ITEMS$adult_item <- ITEMS$name %in% q_dem_groups$adults
    ITEMS$child_item <- ITEMS$name %in% q_dem_groups$children
    ITEMS$neonatal_item <- ITEMS$name %in% q_dem_groups$neonates
    ITEMS$maternal_item <- ITEMS$name %in% q_dem_groups$maternal

    yes_no_types <- grep("yes",
                         tolower(names(table(odk_form$type))),
                         value = TRUE)
    q_yes_no <- odk_form$name[tolower(odk_form$type) %in% yes_no_types]
    ITEMS$n_yes[!(ITEMS$name %in% q_yes_no)] <- NA
    ITEMS$n_no[!(ITEMS$name %in% q_yes_no)] <- NA

    ITEMS$pct_yes[!(ITEMS$name %in% q_yes_no)] <- NA
    ITEMS$pct_no[!(ITEMS$name %in% q_yes_no)] <- NA

   ## devtools::test_file("../tests/testthat/test-item-response.R")
    # That's all folks!
    results <- list(Deaths = DEATHS,
                    Items = ITEMS,
                    DummyDF = ITEM_DEATH_DUMMY)
    return (results)
}
